# I/O 设备

## 了解系统架构

现代计算机架构通常使用 I/O 总线来将 I/O 设备连接到系统。但 I/O 总线并不总是只有一个，而可能会是分层结构：高性能的 I/O 设备，例如承担图形处理的显卡，将使用常规的 I/O 总线；而例如 USB，SATA(串口硬盘) 这些设备的接口则会使用另一个外设 I/O 总线。

分层结构的目的？高性能的总线因为造价高昂，所以总线较短，不能连接太多设备。而性能低的总线就更长，且离 CPU 更远。

另外，为了提升 CPU 的工作效率，通常会使用一个 DMA 来进行设备与内存间的数据交换。

## 设备如何交互

设备通过总线访问和存储系统资源。但现在还需要一个协议来决定它如何工作。

要知道 I/O 的时间片数量是远多于主存和 CPU 的时间片数量的。所以，我们像这样工作：

- 轮询，不断询问设备是否正在 busy 状态；
- 设备空闲，可以接收命令，现在将数据写入数据寄存器；
- 将指令写入指令寄存器，于是设备知道接下来应该执行现在锁请求的命令；
- 轮询，不断询问设备是否已经处理完这个命令；

和之前的锁等问题类似，这样的操作很容易浪费 CPU 时间片。所以我们又引入中断。

> 要知道不是什么时候中断都是最优的——很可能设备处理命令比想象的要快，于是我们只需要轮询几次甚至一次就可以了。这个时候，中断和其相比，要切换上下文到其他进程，还要处理中断例程，再切换回来。这其中的代价可能就远大于轮询了。所以，对于设备速度未知的情况，通常采用混合策略，即先轮询数次，然后如果没有完成，就使用中断——于是，又出现了一个 Magic Number：轮询几次最优？

现在再考虑操作系统如何与外部设备通信。

- 一是直接使用指令来和设备交互。但这样的指令属于特权指令，很容易被滥用，导致磁盘被恶意程序控制，进而让计算机遭受危险；
- 二是内存映射。操作系统将部分内存映射设备空间，在内存中操作，结束后再通过硬件将其转移到设备上映射的空间。例如 UNIX C 的 `mmap()` 接口。

## 磁盘寻道方法

类比内存寻地址的方法。理想情况下，可以将磁盘区域看作一个一维数组。

（实际上，磁盘更应该抽象为一个多级同心圆，磁头总是在某个角度的某级同心圆上。寻找请求节点需要旋转到正确的角度，然后寻道到正确的级上）

### FCFS

按顺序找磁盘节点，和 FIFO 一样。相应的还有后来先服务的 LCFS.

### SSTF

最短寻道时间算法。这是一种贪心的算法，每次都只找当前等待队列中离磁头最近的磁道上请求。而且重要的的是需要知道等待队列的信息，如果等待队列不能很大，其实和先入先出区别不大。但是贪心地每次找最近的，不一定是全局最优的。

### SCAN

暴力地直接遍历，遍历到一头再反向遍历。可以说是一种“电梯”算法。

### C-SCAN

很容易发现 SCAN 算法容易浪费移动次数——从左到右扫描完之后，再从右往左回去，刚刚走过的路大概率没有请求（即使有，堆积的个数平均也比靠右的区域少），所以每次扫描完之后，又会回到起点重新扫描，这样的效率平均下来更高一些（假设请求在各段平均分配）。

### LOOK/C-LOOK

一种优化的 SCAN/C-SCAN 算法。前提是操作系统首先要获取现在请求队列中两个方向上各自最远的请求位置，然后扫描时不再扫描到边界，而是只到这些最远位置即可。

### SPTF

SSTF 所贪心的是“最近的磁道”。但磁道最近不一定磁道移动过去就最快。

## 文件系统

### 文件属性和文件操作

要构建一个文件系统，那么我们得关注文件属性。

一个文件最重要的引用户属性，即其文件名。命名独立于进程和用户，独立于创建其的系统。除此以外，还有：标识符、类型、位置、大小、权限、时间戳等信息。

其次是文件操作。主要的六种基本文件操作：

- 创建文件
- 写文件
- 读文件
- 文件内定位
- 删除文件
- 截断文件（Truncate）

除此以外还有一些特殊的文件操作，例如和文件属性中文件名相关的重命名等。与并发相关的有如文件锁，决定多线程环境下文件是否可以被多线程并发获取等。
