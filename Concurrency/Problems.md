# 经典并发问题

现在我们尝试使用信号量解决一些并发问题。

## 生产者\/消费者问题

在之前对条件变量的讨论中已经解决过这个问题。通常我们也叫它有界缓冲区问题。

现在我们用两个信号量 `full` 和 `empty` 表示缓冲区为空或者满。必须注意对条件变量的操作也是临界操作，相关的 `wait` 和 `post` 依然是需要加锁的。但是要注意，信号量和条件变量不同，它的 `wait` 并不会像 `cond_wait` 一样同时放弃掉锁。因此例如如下的代码：

```c
void *consumer() {
	wait(&mutex);
	wait(&full);
	// consume
	post(&empty);
	post(&mutex);
}
void *producer() {
	wait(&mutex);
	wait(&empty);
	// produce
	post(&full);
	post(&mutex);
}
```

只要缓冲区中没有东西，然后消费者获取锁进入等待，生产者就无法再获取锁并生产，反之亦然。因此这样会导致死锁。但是解决也很简单，改小锁的作用域即可，如下：

```c
void *consumer() {
	wait(&full);
	wait(&mutex);
	// consume
	post(&mutex);
	post(&empty);
}
void *producer() {
	wait(&empty);
	wait(&mutex);
	// produce
	post(&mutex);
	post(&full);
}
```

## 读者-写者锁

有时候，很多操作虽然访问了临界区，但是进行的都是只读操作，并不会修改临界区，所以让只读操作可以并行执行是好的。例如现在有一些“读者”和“写者”，读者只读临界区，而写者要修改临界区。我们可以做如下规定：

分别给一个读锁和写锁，当读者获取读锁时，也会获取一个写者锁，并且读者计数加一。读者获取完读锁之后又会立刻释放读锁。

因此，可以有同时多个读者在读临界区，且多个读者会共同持有一个写者锁。

这样写者就不会进入临界区，造成读者读到的内容发生变化了。

而当读者全部退出时，即读者计数重新变为 0，写锁就会被释放，这个时候写者就可以获取写锁了。

而写者在修改时，因为写锁没有释放，下一个读者（新一批读者的第一个）会等待写锁，因此写时不会发生读取。

## 哲学家就餐问题

一种优雅简单的解决方法：让其中一个哲学家的获取顺序颠倒。

好像也没啥说的（
