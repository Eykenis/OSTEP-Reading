# 并发

这节写的笔记从 “锁和信号量” 开始，了解一些解决并发问题的工具后，再梳理教材上提出的一些并发问题。

**Introduction** 这一节很短，但是必须得了解，所以就把它简单地写在 README 下面吧。

## 线程与线程并发

### 采用多线程的原因

和进程不同，线程是为并发而生的。经典观点认为一个程序只能有一个执行点（一个 PC，或者是 IP 寄存器），程序按代码顺序执行。通常这种模式没什么问题。但是很多时候会出现 CPU 资源没有得到充分使用的情况。例如，一系列固定操作因为在其之前有等待 I/O 的操作，导致这段代码被阻塞，没法提前执行，CPU 资源被浪费。

如果我们为一个进程创建不止一个线程，然后每个线程从相同（或者不同）的位置开始执行，一个最简单的解决办法，I/O 时只让一个线程被阻塞，那么其他线程可以先去执行后面的代码，前面所说的问题就解决了。

**和一直以来的直觉不同，并发更多的时候其实对单处理器的提升更大。** 实际上在多核处理器上采用多线程的效果没有那么明显，因为会有处理器间通信的额外开销，而且多核往往是为了应对更多进程的场景。

### 线程的行为

所有的线程共用一套地址空间和进程的成员变量，等等。但是每个线程也有一套线程本地存储，即相关线程的**栈**。为了数据安全，线程之间也要进行上下文切换，切走的线程将自己的状态保存到 Process Control Block 中。不过，因为使用同一个地址空间，不需要重新设置页表。

### 多线程并不理想

但是，线程数增加的提升并不是线性的。实际上不管使用多少个线程，效率几乎都很难达到 200%。这是因为多线程之间很容易出现冲突，从而需要互相 “让步”。为了保证多线程策略应用在任何程序上都能表现出正确的行为，我们需要设计许多的并发策略。

多线程导致的一个最核心的问题就是临界区问题。

例如，现在有一个变量 `var`, 值为 1. 有两个线程都执行 `var++` 的操作。这个操作的机器操作是：

- 将 var 的值读到线程本地寄存器中
- 寄存器中的值 +1
- 寄存器值放回 var 的地址

现在，线程 1 将 var 的值读到线程本地寄存器中，然后给它+1. 但是，在线程 1 还没有将值送回原地址时，线程 2 先在内存中读取了 var 的值！于是，虽然做了 2 次加操作，但两个线程拿到的值都是 1. 于是便出现了 "1+2=2" 的错误。

这种修改共享变量的代码（块）通常被称作临界区。如果我们不加保护地以多线程的方式执行临界区操作，就会出现类似以上的问题。

## 解决临界区问题

解决临界区问题的工具是锁，信号量，条件变量等内容。例如，通过锁，我们可以避免多个线程同时在临界区工作。而信号量可以解决一些更复杂的同步问题。
