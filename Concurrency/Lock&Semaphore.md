# 锁和信号量

## 锁

在遇到临界区后，我们可以用锁的方法来达到线程安全的目的。

例如，现在有一段代码：

```cpp
x++;
```

显然这属于临界区。我们为这段临界区代码加锁：

```cpp
lock();
x++;
unlock();
```

当线程执行到临界区时，`lock()` 会检查这个锁有没有被上锁。如果上锁，就不进入临界区；否则，该线程就会 ”获得锁“，并进入临界区执行代码。执行完之后再释放锁。

想是这样想，但是 `lock()` 和 `unlock()` 还需要我们实现。

**对于单处理器系统**，一种最简单的办法是在 `lock()`函数中关闭中断，而在 `unlock()` 函数中打开中断。但是这种简单的方法有一些问题：

- 关闭终端属于特权操作。恶意程序可能会借此关闭中断并长期占用资源。
- 只支持单处理器。多处理器不管有没有中断都会有多个线程进入同一临界区的可能。
- 临界区中中断丢失，导致严重的系统问题。因为一般情况下中断不会像进程那样阻塞，这导致 CPU 可能丢失一些重要的中断请求。

### TestAndSet

TestAndSet 是一种经典的乐观锁方案。

假定现在有一个共享变量 `flag`. TestAndSet 方案会在 `lock()` 时检查 `flag` 是否为 1. 如果是，就循环等待。如果不是，就设置 `flag=1`，并进入临界区。这个过程和一般的上锁过程并无区别，区别是其执行时不会被中断，能保证原子操作。因此 TAS 是需要硬件支持的。

> 乐观锁：设置一个专用的锁，可以是变量或者其他封装。锁的获取与释放严格。
>
> 与之相对的悲观锁：使用较为宽松的判断方式，可能是判断某些其他值，开销更少，但高并发条件下效率低。

大多数 CPU 提供原子交换功能，以此来实现 TAS，保证了锁的安全性。

在 x86 上，这个指令是 xchg 和 cmpxchgx 指令，可以原子地交换两个寄存器的值。教材上给出的 x86 的 TAS：

```
lock
cmpxchgl %2, %1
sete %0
```

## 解决自旋锁的忙等问题

上面讲到的实现方法都是自旋锁。自旋锁在没有获取到锁时会循环调用检测。如果是单核 CPU 且没有抢占式调度器，那就会导致系统的全部资源一直在 “等待”锁。即使不是，自旋也会导致忙等问题，忙等就是指 CPU 花了太多精力在“等待”本身上面，while 循环本身占用了过多时间片。

解决忙等的方法可以很简单：

### 放弃 CPU

 在没有获得到锁的时候，sleep 一小段时间，或者操作系统有 `yield` 原语（用于放弃 CPU，让当前线程从 running 变为 ready）时也可以用 `yield`.

但是这种方法有个问题。试想高并发条件下，数量庞大的线程不断地尝试获得锁，每个线程都尝试一次，然后 yield. 这同样会导致大量的时间片浪费。而且还可能发生一个线程一直获得不到锁而在 deschedule 自己，导致饿死的情况。

### 等待队列

每当线程没有成功获取锁时，将其加入等待队列，等待队列中的所有线程都将处于睡眠状态。当使用锁的线程退出临界区并释放锁后，从等待队列中唤醒最早尝试获取锁的线程。

### 两阶段锁

结合自旋和等待队列的方法。一个线程会先尝试自旋一小段时间，如果还是获取不到就进入等待队列。这样做的好处是能让很快就释放锁的那些线程的下一个线程能及时获取锁，在某些条件下比等待队列的表现更好，但也不一定优于只使用等待队列的策略。

现代 Linux 系统采用的就是两阶段锁。

## 条件变量

条件变量是一个显式队列。用于控制让一些线程只有在其他线程导致了某些条件的满足时才往下执行。当一个线程尝试判断条件而失败时，它会将自己加入条件变量的队列并进入睡眠，直到条件满足后才被唤醒。

### 应用：生产者\/消费者问题

这是一个使用条件变量的共享缓冲区资源分配问题。现在有两种进程，一种是生产者，一种是消费者。当生产者线程运行时，**如果缓冲区没有满**，其向缓冲区中添加资源；当消费者线程运行时，**如果缓冲区没有空**，其从缓冲区中取出资源。

下面的步骤表现了生产者\/消费者问题的一系列要解决的问题，以及层级式的解决方法。

1. 首先，生产与消费的操作涉及共享变量临界区，必须是原子性的。所以我们要为这两个操作添加锁。但添加锁不能解决问题。因为只有锁的情况下有可能消费者在生产者生产之前被调度，这样消费者就无法消费。
2. 所以还要加入条件变量用于标识缓冲区。现在我们假设缓冲区的大小为 1. 当生产者生产时，调用 `signal()` 来设置条件变量为 1，表示缓冲区非空。当生产者生产时，如果条件变量为 1，那么循环等待，如果条件变量重新变为 0，表示有消费者使用。相应地，消费者调用 `wait()` 等待条件变量为 1，等到后设置条件变量为 0，并消费掉缓冲区的资源。这样的思路在 1 个生产者与 1 个消费者时能正常工作。
3. 但是，2. 的方法在有多个消费者时不能正常工作！因为消费者在循环等待时也会释放掉锁（否则生产者无法进入自己的临界区修改变量），而当一个消费者 A 等待时，生产者生产之后，会释放信号唤醒睡眠的 A，但此时另一个消费者 B 抢先开始执行，消耗掉了资源，而 A 在唤醒后会继续向下执行，导致 A 消费错误。解决方法是将判断条件变量的语句从 `if` 改为 `while`，这样在重新调度到 A 后，A 发现条件变量还是 0，所以不会往下走而是继续等待。
4. 但多个消费者还会导致另外一个问题：没有规定唤醒哪个线程。有可能会有这种情况：消费者 A 和 B 发现没有可消费的，进入睡眠等待。生产者接着生产完之后也进入睡眠。因为没规定唤醒哪个线程，所以完全有可能唤醒的是消费者 B。然后消费者 B 发现没有可用资源，又接着睡眠，导致三个线程都进入睡眠。
5. 解决 4. 的问题的方法是区分消费者和生产者的条件变量。让生产者只能唤醒消费者，消费者只能唤醒生产者。可以通过让生产者等待变量 1、调整变量 2，消费者等待变量 2、调整变量 1 来达到目的。
6. 以上的思路是建立在缓冲区大小为 1 的假设下的。如果我们需要更大的缓冲区，可以使用指针等方法标识缓冲区是否填满。或者，使用信号量。

## 信号量

定义：信号量是有一个整数值的对象，可以用 wait 和 post 两个函数来操作它（在 POSIX 中，是 `sem_wait()` 和 `sem_post()` ）。

- 信号量是一种更加宽泛的同步原语。设置信号量的一些条件，他们就能拥有和锁或者条件变量一样的作用。（可以认为是锁和条件变量的超集罢）
- 信号量的值能立刻决定其以及其相关的线程的行为。所以初始化信号量是必要的。

> ### POSIX 的 `sem_wait()` 和 `sem_post()`
>
> - `sem_wait`: 如果信号量的值大于 0，直接减一。否则线程将等待直到信号量大于 0.
> - `sem_post`: 如果有线程在等待，唤醒其中一个。否则将信号量加一。
